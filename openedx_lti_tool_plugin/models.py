"""Django Model."""
import json
import re
import uuid
from typing import TypeVar

import shortuuid
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ValidationError
from django.db import models, transaction
from django.db.models import Q, TextChoices
from django.utils.safestring import mark_safe
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django import DjangoDbToolConf
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.learning_sequences import course_context
from openedx_lti_tool_plugin.edxapp_wrapper.site_configuration_module import configuration_helpers
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile
from openedx_lti_tool_plugin.waffle import COURSE_ACCESS_CONFIGURATION

UserT = TypeVar('UserT', bound=AbstractBaseUser)


class LtiProfile(models.Model):
    """LTI 1.3 profile.

    A unique representation of the LTI subject that initiated an LTI launch.

    """

    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name=f'{app_config.name}_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )
    pii = models.JSONField(
        default=dict,
        verbose_name=_('PII'),
        help_text=_('Profile PII.'),
    )

    _initial_pii = None

    class Meta:
        """Model metadata options."""

        verbose_name = 'LTI profile'
        verbose_name_plural = 'LTI profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    def __init__(self, *args: tuple, **kwargs: dict):
        """__init__ method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        super().__init__(*args, **kwargs)
        # Store instance initial field data.
        self._initial_pii = self.pii

    @property
    def short_uuid(self) -> str:
        """str: Short UUID."""
        return shortuuid.encode(self.uuid)[:8]

    @property
    def given_name(self) -> str:
        """str: Given name."""
        return self.pii.get('given_name', '')

    @property
    def middle_name(self) -> str:
        """str: Middle name."""
        return self.pii.get('middle_name', '')

    @property
    def family_name(self) -> str:
        """str: Family name."""
        return self.pii.get('family_name', '')

    @property
    def name(self) -> str:
        """str: Name."""
        # Return name from `pii` field.
        if name := self.pii.get('name', ''):
            return name

        # Build list with available name parts.
        name_parts = [self.given_name, self.middle_name, self.family_name]

        # Build name using list of available name parts.
        return ' '.join(part for part in name_parts if part)

    @property
    def username(self) -> str:
        """str: Username."""
        # Return username from `user` attribute.
        if getattr(self, 'user', None):
            return self.user.username

        try:
            # Return username using `name` and short UUID.
            name = self.name.split()
            name = name[0][:8].lower()
            name = re.sub(r'[\W_]+', '', name)

            return f'{name}.{self.short_uuid}'
        except IndexError:
            # Return username using short UUID.
            return f'{self.short_uuid}'

    @property
    def email(self) -> str:
        """str: Email address."""
        # Return email from `user` attribute.
        if getattr(self, 'user', None):
            return self.user.email

        # Build email using UUID and app domain_name.
        return f'{self.uuid}@{app_config.domain_name}'

    def user_collision(self) -> bool:
        """Check for user collision.

        Returns:
            True if a user collides with another user.
            False if no user collision is found.

        """
        return get_user_model().objects.filter(
            Q(email=self.email)
            | Q(username=self.username)
        ).exclude(
            email=self.email,
            username=self.username,
        ).exists()

    def configure_user(self):
        """Configure user."""
        # Configure if no user is set.
        if getattr(self, 'user', None):
            return
        # Regenerate uuid on user collision.
        while self.user_collision():
            self.uuid = uuid.uuid4()
        # Get or create user.
        self.user, _created = get_user_model().objects.get_or_create(
            email=self.email,
            username=self.username,
        )
        # Set unusable user password.
        self.user.set_unusable_password()

    @transaction.atomic
    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        # Merge initial instance PII data with new PII data.
        self.pii = {**self._initial_pii, **self.pii}
        # Configure user.
        self.configure_user()
        # Update or create user profile.
        user_profile().objects.update_or_create(
            user=self.user,
            # Truncate name to max_length limit.
            defaults={'name': self.name[:255]},
        )

        return super().save(*args, **kwargs)

    def __str__(self) -> str:
        """Model string representation."""
        return f'<LtiProfile, ID: {self.id}>'


class LtiToolConfiguration(models.Model):
    """LTI Tool Configuration.

    A model to store LTI tool configuration.

    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    class UserProvisioningMode(TextChoices):
        """Enumeration for user provisioning modes."""

        NEW_ACCOUNTS_ONLY = 'new_only', _('New accounts only (automatic)')
        EXISTING_AND_NEW = 'existing_and_new', _('Existing and new accounts (prompt)')
        EXISTING_ONLY = 'existing_only', _('Existing accounts only (prompt)')

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name=f'{app_config.name}_lti_tool_configuration',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )
    user_provisioning_mode = models.CharField(
        max_length=50,
        choices=UserProvisioningMode.choices,
        default=UserProvisioningMode.NEW_ACCOUNTS_ONLY,
        verbose_name=_('User Provisioning Mode'),
        help_text=mark_safe(_("""
        <p>Determines how user accounts are provisioned during an LTI launch:</p>
        <ul>
          <li><strong>New accounts only (automatic)</strong> -
            New accounts are created automatically on first launch
            and reused for subsequent launches.</li>
          <li><strong>Existing and new accounts (prompt)</strong> -
            User prompted to link an existing account or create a new one.
            That selection is used for subsequent launches.</li>
          <li><strong>Existing accounts only (prompt)</strong> -
            Only existing accounts may be used. Without an existing account,
            users cannot access shared resources.</li>
        </ul>
        """)),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI tool configuration'
        verbose_name_plural = 'LTI tool configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)

            if not isinstance(allowed_course_ids, list):
                raise ValueError()
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiToolConfiguration, ID: {self.id}>'


class CourseContextQuerySet(models.QuerySet):
    """CourseContext QuerySet."""

    def all_for_lti_tool(self, iss: str, aud: str) -> models.QuerySet:
        """Query all CourseContext objects available for an LtiTool.

        Args:
            iss: Issuer claim.
            aud: Audience claim.

        Returns:
            All CourseContext objects if COURSE_ACCESS_CONFIGURATION
            switch is disabled.

            All objects with a Course ID that is in the
            LtiToolConfiguration.allowed_course_ids field.

            None if COURSE_ACCESS_CONFIGURATION switch is enabled and
            no LtiToolConfiguration can be found for the queried
            LtiTool.

        """
        if not COURSE_ACCESS_CONFIGURATION.is_enabled():
            return self.all()

        try:
            lti_tool_config = LtiToolConfiguration.objects.get(
                lti_tool=DjangoDbToolConf().get_lti_tool(iss, aud),
            )
        except LtiToolConfiguration.DoesNotExist:
            return self.none()

        return self.filter(
            learning_context__context_key__in=json.loads(
                lti_tool_config.allowed_course_ids,
            ),
        )

    def filter_by_site_orgs(self) -> models.QuerySet:
        """Filter QuerySet by site configuration orgs.

        Returns:
            QuerySet with CourseContext objects with an org matching the
            site configuration org list if the site configuration
            `course_org_filter` setting is set.

            An unfiltered QuerySet if the site configuration
            `course_org_filter` setting is not set

        """
        if site_orgs := configuration_helpers().get_current_site_orgs():
            return self.filter(
                pk__in=[
                    course_context.pk
                    for course_context in self
                    if course_context.org in site_orgs
                ]
            )

        return self


class CourseContext(course_context()):
    """CourseContext Model."""

    objects = CourseContextQuerySet.as_manager()

    class Meta:
        """Model metadata options."""

        proxy = True

    @property
    def course_id(self):
        """str: Course ID."""
        return self.learning_context.context_key

    @property
    def org(self):
        """str: Organization."""
        return self.course_id.org

    @property
    def title(self):
        """str: Title."""
        return self.learning_context.title
