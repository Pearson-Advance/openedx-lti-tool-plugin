"""Models for openedx_lti_tool_plugin."""
import json
import uuid
from typing import TypeVar

from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ValidationError
from django.db import models, transaction
from django.utils.functional import cached_property
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile
from openedx_lti_tool_plugin.utils import get_pii_from_claims

UserT = TypeVar('UserT', bound=AbstractBaseUser)


class LtiProfile(models.Model):
    """LTI 1.3 profile for Open edX users.

    A unique representation of the LTI subject that initiated an LTI launch.
    """

    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )
    pii = models.JSONField(
        default=dict,
        verbose_name=_('PII'),
        help_text=_('Profile PII.'),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI profile'
        verbose_name_plural = 'LTI profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    @cached_property
    def email(self) -> str:
        """LTI profile email address."""
        return f'{self.uuid}@{app_config.name}'

    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        In this method we try to validate if the LtiProfile contains an user,
        if no user is found then we create a new user for this instance.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        if getattr(self, 'user', None):
            return super().save(*args, **kwargs)

        with transaction.atomic():
            # Get or create edx user.
            self.user, created = get_user_model().objects.get_or_create(
                username=f'{app_config.name}.{self.uuid}',
                email=self.email,
            )

            # Set password unusable if user is created.
            if created:
                self.user.set_unusable_password()  # LTI users can only auth throught LTI launches.
                self.user.save()

            # Get or create edx user profile.
            user_profile().objects.get_or_create(user=self.user)

            return super().save(*args, **kwargs)

    def update_pii(self, **kwargs: dict):
        """
        Update profile PII.

        This method will get all PII from kwargs and will check if any of the values
        exist or are different from the value currently set on the model instance
        and update the value if true.

        Args:
            **kwargs: Arbitrary keyword arguments.
        """
        # Get PII from keyword argument.
        new_pii = get_pii_from_claims(kwargs)
        # Create a dictionary with existing PII to compare against new PII.
        merged_pii = {**self.pii}

        # Add new PII value to merged dictionary of PII if the new PII value exists
        # and is different from existing PII value on this profile.
        for field, value in new_pii.items():
            if value and value != merged_pii.get(field):
                merged_pii[field] = value

        if merged_pii != self.pii:
            self.pii = merged_pii
            self.save(update_fields=['pii'])

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiProfile, ID: {self.id}>'


class CourseAccessConfiguration(models.Model):
    """Course access configuration.

    A model to store LTI tool course access configuration.
    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_course_permission',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )

    class Meta:
        """Meta options."""

        verbose_name = 'Course access configuration'
        verbose_name_plural = 'Course access configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)

            if not isinstance(allowed_course_ids, list):
                raise ValueError()
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<CourseAccessConfiguration, ID: {self.id}>'
