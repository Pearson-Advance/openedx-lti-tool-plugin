"""Models for openedx_lti_tool_plugin."""
from __future__ import annotations

import datetime
import json
import uuid
from typing import Optional, TypeVar, Union

from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ValidationError
from django.db import models, transaction
from django.db.models import QuerySet
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django import DjangoDbToolConf, DjangoMessageLaunch
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool
from pylti1p3.grade import Grade

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile
from openedx_lti_tool_plugin.utils import get_pii_from_claims
from openedx_lti_tool_plugin.validators import validate_context_key

UserT = TypeVar('UserT', bound=AbstractBaseUser)


class LtiProfile(models.Model):
    """LTI 1.3 profile for Open edX users.

    A unique representation of the LTI subject that initiated an LTI launch.
    """

    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )
    pii = models.JSONField(
        default=dict,
        verbose_name=_('PII'),
        help_text=_('Profile PII.'),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI profile'
        verbose_name_plural = 'LTI profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        In this method we try to validate if the LtiProfile contains an user,
        if no user is found then we create a new user for this instance.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        if getattr(self, 'user', None):
            return super().save(*args, **kwargs)

        with transaction.atomic():
            # Get or create edx user.
            self.user, created = get_user_model().objects.get_or_create(
                username=f'{app_config.name}.{self.uuid}',
                email=f'{self.uuid}@{app_config.name}',
            )

            # Set password unusable if user is created.
            if created:
                self.user.set_unusable_password()  # LTI users can only auth throught LTI launches.
                self.user.save()

            # Get or create edx user profile.
            user_profile().objects.get_or_create(user=self.user)

            return super().save(*args, **kwargs)

    def update_pii(self, **kwargs: dict):
        """
        Update profile PII.

        This method will get all PII from kwargs and will check if any of the values
        exist or are different from the value currently set on the model instance
        and update the value if true.

        Args:
            **kwargs: Arbitrary keyword arguments.
        """
        # Get PII from keyword argument.
        new_pii = get_pii_from_claims(kwargs)
        # Create a dictionary with existing PII to compare against new PII.
        merged_pii = {**self.pii}

        # Add new PII value to merged dictionary of PII if the new PII value exists
        # and is different from existing PII value on this profile.
        for field, value in new_pii.items():
            if value and value != merged_pii.get(field):
                merged_pii[field] = value

        if merged_pii != self.pii:
            self.pii = merged_pii
            self.save(update_fields=['pii'])

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiProfile, ID: {self.id}>'


class CourseAccessConfiguration(models.Model):
    """Course access configuration.

    A model to store LTI tool course access configuration.
    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_course_permission',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )

    class Meta:
        """Meta options."""

        verbose_name = 'Course access configuration'
        verbose_name_plural = 'Course access configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)

            if not isinstance(allowed_course_ids, list):
                raise ValueError()
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<CourseAccessConfiguration, ID: {self.id}>'


class LtiGradedResourceManager(models.Manager):
    """A manager for the LtiGradedResource model."""

    def all_from_user_id(self, user_id: UserT, context_key: str) -> Optional[QuerySet]:
        """
        Retrieve all resources for a given user ID and context key.

        Args:
            user_id: Open edX user object.
            context_key: Graded resource opaque key string.

        Returns:
            LTI graded resource query or None.
        """
        return self.filter(
            lti_profile=LtiProfile.objects.filter(user__id=user_id).first(),
            context_key=context_key,
        )


class LtiGradedResource(models.Model):
    """LTI graded resource.

    A unique representation of a LTI graded resource.
    """

    objects = LtiGradedResourceManager()
    lti_profile = models.ForeignKey(
        LtiProfile,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_graded_resource',
        help_text=_('The LTI profile that launched the resource.'),
    )
    context_key = models.CharField(
        max_length=255,
        help_text=_('The opaque key string of the resource.'),
        validators=[validate_context_key],
    )
    lineitem = models.URLField(
        max_length=255,
        help_text=_('The AGS lineitem URL.'),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI graded resource'
        verbose_name_plural = 'LTI graded resources'
        unique_together = ['lti_profile', 'context_key', 'lineitem']

    def update_score(
        self,
        given_score: Union[int, float],
        max_score: Union[int, float],
        timestamp: datetime.datetime,
    ):
        """
        Use LTI's score service to update the LTI platform's gradebook.

        This method sends a request to the LTI platform to update the assignment score.

        Args:
            given_score: Score given to the graded resource.
            max_score: Graded resource max score.
            timestamp: Score timestamp object.
        """
        # Create launch message object and set values.
        launch_message = DjangoMessageLaunch(request=None, tool_config=DjangoDbToolConf())
        launch_message.set_auto_validation(enable=False)
        launch_message.set_jwt({
            'body': {
                'iss': self.lti_profile.platform_id,
                'aud': self.lti_profile.client_id,
                'https://purl.imsglobal.org/spec/lti-ags/claim/endpoint': {
                    'lineitem': self.lineitem,
                    'scope': {
                        'https://purl.imsglobal.org/spec/lti-ags/scope/lineitem',
                        'https://purl.imsglobal.org/spec/lti-ags/scope/score',
                    },
                },
            },
        })
        launch_message.set_restored()
        launch_message.validate_registration()
        # Get AGS service object.
        ags = launch_message.get_ags()
        # Create grade object and set grade values.
        grade = Grade()
        grade.set_score_given(given_score)
        grade.set_score_maximum(max_score)
        grade.set_timestamp(timestamp.isoformat())
        grade.set_activity_progress('Submitted')
        grade.set_grading_progress('FullyGraded')
        grade.set_user_id(self.lti_profile.subject_id)
        # Send grade update.
        ags.put_grade(grade)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiGradedResource, ID: {self.id}>'

    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        In this method we run field validators.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        self.full_clean()
        super().save(*args, **kwargs)
