"""Models for openedx_lti_tool_plugin."""
from __future__ import annotations

import datetime
import json
import uuid
from typing import Optional, Tuple, TypeVar, Union

from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ValidationError
from django.db import models, transaction
from django.db.models import QuerySet
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.django.models import LearningContextKeyField
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django import DjangoDbToolConf, DjangoMessageLaunch
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool
from pylti1p3.grade import Grade

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile

UserT = TypeVar('UserT', bound=AbstractBaseUser)


class LtiProfileManager(models.Manager):
    """LTI 1.3 profile model manager."""

    def get_from_claims(self, iss: str, aud: str, sub: str) -> LtiProfile:
        """Get an instance from LTI 1.3 launch claims.

        Args:
            iss: LTI platform id claim.
            aud: LTI client id claim.
            sub: LTI subject id claim.

        Returns:
            LTI profile instance from launch claims.
        """
        return self.get(platform_id=iss, client_id=aud, subject_id=sub)

    def get_or_create_from_claims(self, iss: str, aud: str, sub: str) -> Tuple[LtiProfile, bool]:
        """Get or create an instance from LTI 1.3 launch claims.

        Args:
            iss: LTI platform id claim.
            aud: LTI client id claim.
            sub: LTI subject id claim.

        Returns:
            LTI profile instance from launch claims and a
            boolean specifying whether a new LTI profile was created.
        """
        try:
            return self.get_from_claims(iss=iss, aud=aud, sub=sub), False
        except self.model.DoesNotExist:
            return self.create(platform_id=iss, client_id=aud, subject_id=sub), True


class LtiProfile(models.Model):
    """LTI 1.3 profile for Open edX users.

    A unique representation of the LTI subject that initiated an LTI launch.
    """

    objects = LtiProfileManager()
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI Profile'
        verbose_name_plural = 'LTI Profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        In this method we try to validate if the LtiProfile contains an user,
        if no user is found then we create a new user for this instance.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        if getattr(self, 'user', None):
            return super().save(*args, **kwargs)

        with transaction.atomic():
            # Create edx user.
            self.user = get_user_model().objects.create(
                username=f'{app_config.name}.{self.uuid}',
                email=f'{self.uuid}@{app_config.name}',
            )
            self.user.set_unusable_password()  # LTI users can only auth throught LTI launches.
            self.user.save()

            # Create edx user profile.
            profile = user_profile()(user=self.user)
            profile.save()

            return super().save(*args, **kwargs)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiProfile, ID: {self.id}>'


class CourseAccessConfiguration(models.Model):
    """Course access configuration.

    A model to store LTI tool course access configuration.
    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_course_permission',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )

    class Meta:
        """Meta options."""

        verbose_name = 'Course access configuration'
        verbose_name_plural = 'Course access configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)
            isinstance(allowed_course_ids, list)
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<CourseAccessConfiguration, ID: {self.id}>'


class LtiGradedResourceManager(models.Manager):
    """A manager for the LtiGradedResource model."""

    def all_from_user_id(self, user_id: UserT, context_key: str) -> Optional[QuerySet]:
        """
        Retrieve all resources for a given user ID and context key.

        Args:
            user_id: Open edX user object.
            context_key: Graded resource opaque key string.

        Returns:
            LTI graded resource query or None.
        """
        return self.filter(
            lti_profile=LtiProfile.objects.filter(user__id=user_id).first(),
            context_key=context_key,
        )


class LtiGradedResource(models.Model):
    """LTI graded resource.

    A unique representation of a LTI graded resource.
    """

    objects = LtiGradedResourceManager()
    lti_profile = models.ForeignKey(
        LtiProfile,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_graded_resource',
        help_text=_('The LTI profile that launched the resource.'),
    )
    context_key = LearningContextKeyField(
        max_length=255,
        help_text=_('The opaque key string of the resource.'),
    )
    lineitem = models.URLField(
        max_length=255,
        help_text=_('The AGS lineitem URL.'),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI graded resource'
        verbose_name_plural = 'LTI graded resources'
        unique_together = ['lti_profile', 'context_key', 'lineitem']

    def update_score(
        self,
        given_score: Union[int, float],
        max_score: Union[int, float],
        timestamp: datetime.datetime,
    ):
        """
        Use LTI's score service to update the LTI platform's gradebook.

        This method sends a request to the LTI platform to update the assignment score.

        Args:
            given_score: Score given to the graded resource.
            max_score: Graded resource max score.
            timestamp: Score timestamp object.
        """
        # Create launch message object and set values.
        launch_message = DjangoMessageLaunch(request=None, tool_config=DjangoDbToolConf())
        launch_message.set_auto_validation(enable=False)
        launch_message.set_jwt({
            'body': {
                'iss': self.lti_profile.platform_id,
                'aud': self.lti_profile.client_id,
                'https://purl.imsglobal.org/spec/lti-ags/claim/endpoint': {
                    'lineitem': self.lineitem,
                    'scope': {
                        'https://purl.imsglobal.org/spec/lti-ags/scope/lineitem',
                        'https://purl.imsglobal.org/spec/lti-ags/scope/score',
                    },
                },
            },
        })
        launch_message.set_restored()
        launch_message.validate_registration()
        launch_message.get_ags()
        # Create grade object and set grade values.
        grade = Grade()
        grade.set_score_given(given_score)
        grade.set_score_maximum(max_score)
        grade.set_timestamp(timestamp.isoformat())
        grade.set_activity_progress('Submitted')
        grade.set_grading_progress('FullyGraded')
        grade.set_user_id(self.lti_profile.subject_id)
        # Send grade update.
        launch_message.put_grade(grade)  # pylint: disable=no-member

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiGradedResource, ID: {self.id}>'
