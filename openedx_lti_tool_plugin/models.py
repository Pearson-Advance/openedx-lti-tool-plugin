"""Django Models."""
import json
import re
import uuid
from typing import TypeVar

import shortuuid
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.core.validators import EmailValidator
from django.db import models, transaction
from django.db.models import Q, TextChoices
from django.utils.safestring import mark_safe
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django import DjangoDbToolConf
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.learning_sequences import course_context
from openedx_lti_tool_plugin.edxapp_wrapper.site_configuration_module import configuration_helpers
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile
from openedx_lti_tool_plugin.waffle import COURSE_ACCESS_CONFIGURATION

UserT = TypeVar('UserT', bound=AbstractBaseUser)
User = get_user_model()
UserProfile = user_profile()


class LtiProfile(models.Model):
    """LTI 1.3 Profile.

    This model represents the profile created to uniquely identify an LTI 1.3 launch subject.

    """

    uuid = models.UUIDField(
        default=uuid.uuid4,
        unique=True,
        verbose_name=_('UUID'),
        editable=False,
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name=f'{app_config.name}_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )
    pii = models.JSONField(
        default=dict,
        verbose_name=_('PII'),
        help_text=_('Personally Identifiable Information.'),
    )

    _initial_pii = None

    class Meta:
        """Model metadata options."""

        verbose_name = 'LTI profile'
        verbose_name_plural = 'LTI profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    def __init__(self, *args: tuple, **kwargs: dict):
        """__init__ method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        super().__init__(*args, **kwargs)

        # Store initial pii field data.
        self._initial_pii = self.pii

    @property
    def short_uuid(self) -> str:
        """str: Short UUID."""
        return shortuuid.encode(self.uuid)[:8]

    @property
    def given_name(self) -> str:
        """str: Given name."""
        return self.pii.get('given_name', '')

    @property
    def middle_name(self) -> str:
        """str: Middle name."""
        return self.pii.get('middle_name', '')

    @property
    def family_name(self) -> str:
        """str: Family name."""
        return self.pii.get('family_name', '')

    @property
    def name(self) -> str:
        """str: Name."""
        # Return name from pii field.
        if name := self.pii.get('name', ''):
            return name

        # Build list with available name parts.
        name_parts = [self.given_name, self.middle_name, self.family_name]

        # Build name using list of available name parts.
        return ' '.join(part for part in name_parts if part)

    @property
    def email(self) -> str:
        """str: Email.

        Returns:
            Email built with uuid field and app_config.domain_name.

        """
        return f'{self.uuid}@{app_config.domain_name}'

    @property
    def pii_email(self) -> str:
        """str: PII email.

        Returns:
            Email from pii field if valid.

        """
        try:
            email = self.pii.get('email', '')
            EmailValidator()(email)

            return email
        except ValidationError:
            return ''

    @property
    def username(self) -> str:
        """str: Username."""
        # Return from user field.
        if getattr(self, 'user', None):
            return self.user.username

        try:
            # Return using name and short_uuid.
            name = self.name.split()
            name = name[0][:8].lower()
            name = re.sub(r'[\W_]+', '', name)

            return f'{name}.{self.short_uuid}'
        except IndexError:
            # Return using short_uuid.
            return f'{self.short_uuid}'

    @property
    def user_profile_field_values(self) -> dict:
        """str: UserProfile field values.

        Returns:
            Dictionary with UserProfile field values.

        """
        return {
            # Truncate name to field max_length limit.
            'name': self.name[:255],
        }

    def can_create_user_with_pii_email(self) -> bool:
        """Check if User can be created with pii_email.

        Returns:
            True if User can be created with pii_email.
            False if User cannot be created with pii_email.

        """
        return (
            self.pii_email
            and not User.objects.filter(
                email=self.pii_email,
            ).exists()
        )

    @staticmethod
    def check_user_collides(email: str, username: str) -> bool:
        """Check if User collides.

        Args:
            email: User email.
            username: User username.

        Returns:
            True if User collides.
            False if User does not collide.

        """
        return User.objects.filter(
            Q(email=email) | Q(username=username)
        ).exclude(
            email=email,
            username=username,
        ).exists()

    def prevent_user_collision(self, email: str, username: str):
        """Prevent User collision.

        Regenerate uuid field if User collides.
        This is done to avoid a collision with an existing User
        when creating an User using an auto-generated username or email.

        Args:
            email: User email.
            username: User username.

        """
        while self.check_user_collides(email, username):
            self.uuid = uuid.uuid4()

    def create_user(self) -> UserT:
        """Create User."""
        # Create User with pii_email.
        if self.can_create_user_with_pii_email():
            self.prevent_user_collision(self.pii_email, self.username)

            return User.objects.create(
                email=self.pii_email,
                username=self.username,
            )

        # Create User with email and username.
        self.prevent_user_collision(self.email, self.username)

        return User.objects.create(
            email=self.email,
            username=self.username,
        )

    def configure_user(self):
        """Configure User."""
        # Create User if user field is not set.
        if not getattr(self, 'user', None):
            self.user: UserT = self.create_user()
            self.user.set_unusable_password()

    def configure_user_profile(self):
        """Configure UserProfile."""
        try:
            # Update UserProfile.
            profile = UserProfile.objects.get(user=self.user)
            field_values = {}

            # Only update UserProfile if email not autogenerated.
            if f'@{app_config.domain_name}' in self.user.email:
                field_values = self.user_profile_field_values

            for field, value in field_values.items():
                setattr(profile, field, value)

            profile.save()
        except ObjectDoesNotExist:
            # Create UserProfile.
            UserProfile.objects.create(
                user=self.user,
                **self.user_profile_field_values,
            )

    @transaction.atomic
    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        # Merge initial pii field data with new pii data.
        self.pii = {**self._initial_pii, **self.pii}

        # Configure User.
        self.configure_user()

        # Configure UserProfile.
        self.configure_user_profile()

        return super().save(*args, **kwargs)

    def __str__(self) -> str:
        """Model string representation."""
        return f'<LtiProfile, ID: {self.id}>'


class LtiToolConfiguration(models.Model):
    """LTI Tool Configuration.

    A model to store LTI tool configuration.

    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    class UserProvisioningMode(TextChoices):
        """Enumeration for user provisioning modes."""

        NEW_ACCOUNTS_ONLY = 'new_only', _('New accounts only (automatic)')
        EXISTING_AND_NEW = 'existing_and_new', _('Existing and new accounts (prompt)')
        EXISTING_ONLY = 'existing_only', _('Existing accounts only (prompt)')

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name=f'{app_config.name}_lti_tool_configuration',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )
    user_provisioning_mode = models.CharField(
        max_length=50,
        choices=UserProvisioningMode.choices,
        default=UserProvisioningMode.NEW_ACCOUNTS_ONLY,
        verbose_name=_('User Provisioning Mode'),
        help_text=mark_safe(_("""
        <p>Determines how user accounts are provisioned during an LTI launch:</p>
        <ul>
          <li><strong>New accounts only (automatic)</strong> -
            New accounts are created automatically on first launch
            and reused for subsequent launches.</li>
          <li><strong>Existing and new accounts (prompt)</strong> -
            User prompted to link an existing account or create a new one.
            That selection is used for subsequent launches.</li>
          <li><strong>Existing accounts only (prompt)</strong> -
            Only existing accounts may be used. Without an existing account,
            users cannot access shared resources.</li>
        </ul>
        """)),
    )

    class Meta:
        """Meta options."""

        verbose_name = 'LTI tool configuration'
        verbose_name_plural = 'LTI tool configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)

            if not isinstance(allowed_course_ids, list):
                raise ValueError()
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def allows_linking_user(self) -> bool:
        """Check if instance allows linking User to LtiProfile.

        Returns:
            True if linking User is allowed.
            False if linking User is not allowed.

        """
        return self.user_provisioning_mode in [
            self.UserProvisioningMode.EXISTING_ONLY,
            self.UserProvisioningMode.EXISTING_AND_NEW,
        ]

    def requires_linking_user(self) -> bool:
        """Check if instance requires linking User to LtiProfile.

        Returns:
            True if linking User is required.
            False if linking User is not required.

        """
        return self.user_provisioning_mode == self.UserProvisioningMode.EXISTING_ONLY

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<LtiToolConfiguration, ID: {self.id}>'


class CourseContextQuerySet(models.QuerySet):
    """CourseContext QuerySet."""

    def all_for_lti_tool(self, iss: str, aud: str) -> models.QuerySet:
        """Query all CourseContext objects available for an LtiTool.

        Args:
            iss: Issuer claim.
            aud: Audience claim.

        Returns:
            All CourseContext objects if COURSE_ACCESS_CONFIGURATION
            switch is disabled.

            All objects with a Course ID that is in the
            LtiToolConfiguration.allowed_course_ids field.

            None if COURSE_ACCESS_CONFIGURATION switch is enabled and
            no LtiToolConfiguration can be found for the queried
            LtiTool.

        """
        if not COURSE_ACCESS_CONFIGURATION.is_enabled():
            return self.all()

        try:
            lti_tool_config = LtiToolConfiguration.objects.get(
                lti_tool=DjangoDbToolConf().get_lti_tool(iss, aud),
            )
        except LtiToolConfiguration.DoesNotExist:
            return self.none()

        return self.filter(
            learning_context__context_key__in=json.loads(
                lti_tool_config.allowed_course_ids,
            ),
        )

    def filter_by_site_orgs(self) -> models.QuerySet:
        """Filter QuerySet by site configuration orgs.

        Returns:
            QuerySet with CourseContext objects with an org matching the
            site configuration org list if the site configuration
            `course_org_filter` setting is set.

            An unfiltered QuerySet if the site configuration
            `course_org_filter` setting is not set

        """
        if site_orgs := configuration_helpers().get_current_site_orgs():
            return self.filter(
                pk__in=[
                    course_context.pk
                    for course_context in self
                    if course_context.org in site_orgs
                ]
            )

        return self


class CourseContext(course_context()):
    """CourseContext Model."""

    objects = CourseContextQuerySet.as_manager()

    class Meta:
        """Model metadata options."""

        proxy = True

    @property
    def course_id(self):
        """str: Course ID."""
        return self.learning_context.context_key

    @property
    def org(self):
        """str: Organization."""
        return self.course_id.org

    @property
    def title(self):
        """str: Title."""
        return self.learning_context.title
