"""Django Model."""
import json
import uuid
from typing import TypeVar

from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractBaseUser
from django.core.exceptions import ValidationError
from django.db import models, transaction
from django.utils.translation import gettext_lazy as _
from opaque_keys import InvalidKeyError
from opaque_keys.edx.keys import CourseKey
from pylti1p3.contrib.django.lti1p3_tool_config.models import LtiTool

from openedx_lti_tool_plugin.apps import OpenEdxLtiToolPluginConfig as app_config
from openedx_lti_tool_plugin.edxapp_wrapper.student_module import user_profile

UserT = TypeVar('UserT', bound=AbstractBaseUser)


class LtiProfile(models.Model):
    """LTI 1.3 profile.

    A unique representation of the LTI subject that initiated an LTI launch.

    """

    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    user = models.OneToOneField(
        get_user_model(),
        on_delete=models.CASCADE,
        related_name=f'{app_config.name}_lti_profile',
        verbose_name=_('Open edX user'),
        editable=False,
    )
    platform_id = models.URLField(
        max_length=255,
        verbose_name=_('Platform ID'),
        help_text=_('Platform ID this profile belongs to.'),
    )
    client_id = models.CharField(
        max_length=255,
        verbose_name=_('Client ID'),
        help_text=_('Client ID generated by the LTI platform.'),
    )
    subject_id = models.CharField(
        max_length=255,
        verbose_name=_('Subject ID'),
        help_text=_('Identifies the entity that initiated the launch request.'),
    )
    pii = models.JSONField(
        default=dict,
        verbose_name=_('PII'),
        help_text=_('Profile PII.'),
    )

    _initial_pii = None

    class Meta:
        """Model metadata options."""

        verbose_name = 'LTI profile'
        verbose_name_plural = 'LTI profiles'
        unique_together = ['platform_id', 'client_id', 'subject_id']
        indexes = [
            models.Index(
                fields=['platform_id', 'client_id', 'subject_id'],
                name='lti_profile_identity_claims',
            ),
        ]

    def __init__(self, *args: tuple, **kwargs: dict):
        """__init__ method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        super().__init__(*args, **kwargs)
        # Store instance initial field data.
        self._initial_pii = self.pii

    @property
    def username(self) -> str:
        """str: Username."""
        return f'{app_config.name}.{self.uuid}'

    @property
    def email(self) -> str:
        """str: Email address."""
        return f'{self.uuid}@{app_config.name}'

    @property
    def name(self) -> str:
        """str: Name."""
        name = self.pii.get('name', '')
        given_name = self.pii.get('given_name', '')
        middle_name = self.pii.get('middle_name', '')
        family_name = self.pii.get('family_name', '')

        if name:
            return name

        if given_name and middle_name and family_name:
            return f'{given_name} {middle_name} {family_name}'

        if given_name and family_name:
            return f'{given_name} {family_name}'

        return given_name

    @transaction.atomic
    def save(self, *args: tuple, **kwargs: dict):
        """Model save method.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        """
        # Merge initial instance PII data with new PII data.
        self.pii = {**self._initial_pii, **self.pii}
        # Get or create user.
        if not getattr(self, 'user', None):
            self.user, _created = get_user_model().objects.get_or_create(
                username=self.username,
                email=self.email,
            )
            # Set unusable user password.
            self.user.set_unusable_password()
        # Update or create user profile.
        user_profile().objects.update_or_create(
            user=self.user,
            defaults={'name': self.name},
        )

        return super().save(*args, **kwargs)

    def __str__(self) -> str:
        """Model string representation."""
        return f'<LtiProfile, ID: {self.id}>'


class CourseAccessConfiguration(models.Model):
    """Course access configuration.

    A model to store LTI tool course access configuration.
    """

    EXAMPLE_ID_LIST = 'Example: ["id-1", "id-2", ...]'

    lti_tool = models.OneToOneField(
        LtiTool,
        on_delete=models.CASCADE,
        related_name='openedx_lti_tool_plugin_course_permission',
        verbose_name=_('LTI Tool'),
    )
    allowed_course_ids = models.TextField(
        verbose_name=_('Allowed Course IDs'),
        help_text=_(f'List of allowed courses IDs. {EXAMPLE_ID_LIST}'),
        default=[],
    )

    class Meta:
        """Meta options."""

        verbose_name = 'Course access configuration'
        verbose_name_plural = 'Course access configurations'

    def clean(self):
        """Model clean method.

        In this method we try to validate if the allowed_course_ids field
        is a valid list, Example: ["course-id-1", "course-id-2", ...].

        And will also validate that each course ID is a valid course ID.
        """
        try:
            allowed_course_ids = json.loads(self.allowed_course_ids)

            if not isinstance(allowed_course_ids, list):
                raise ValueError()
        except ValueError as exc:
            raise ValidationError({
                'allowed_course_ids': _(f'Should be a list. {self.EXAMPLE_ID_LIST}'),
            }) from exc

        invalid_course_ids = []
        # Validate the IDs on the allowed_course_ids list.
        for course_id in allowed_course_ids:
            try:
                CourseKey.from_string(course_id)
            except InvalidKeyError:
                invalid_course_ids.append(course_id)
        # Raise exception on any invalid course ID on allowed_course_ids.
        if invalid_course_ids:
            raise ValidationError({
                'allowed_course_ids': _(f'Invalid course IDs: {invalid_course_ids}'),
            })

    def is_course_id_allowed(self, course_id: str) -> bool:
        """Check if a course ID is allowed.

        Args:
            course_id: Course ID string.

        Returns:
            True if course ID is allowed or false if course ID is not allowed.
        """
        return course_id in json.loads(self.allowed_course_ids)

    def __str__(self) -> str:
        """Get a string representation of this model instance."""
        return f'<CourseAccessConfiguration, ID: {self.id}>'
